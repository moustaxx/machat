"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Conversation {
  id: Int!
  name: String!
  messages(first: Int, last: Int, before: MessageWhereUniqueInput, after: MessageWhereUniqueInput): [Message!]!
  createdAt: DateTime!
  participants(first: Int, last: Int, before: PersonWhereUniqueInput, after: PersonWhereUniqueInput): [Person!]!
}

type ConversationConnection {
  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types
  """
  edges: [ConversationEdge!]!

  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

input ConversationCreateInput {
  createdAt: DateTime
  name: String!
  messages: MessageCreateManyWithoutConversationInput
  lastRead: LastReadCreateManyWithoutConversationInput
  participants: PersonCreateManyWithoutConversationsInput
}

input ConversationCreateManyWithoutParticipantsInput {
  create: [ConversationCreateWithoutParticipantsInput!]
  connect: [ConversationWhereUniqueInput!]
  connectOrCreate: [ConversationCreateOrConnectWithoutparticipantsInput!]
}

input ConversationCreateOneWithoutLastReadInput {
  create: ConversationCreateWithoutLastReadInput
  connect: ConversationWhereUniqueInput
  connectOrCreate: ConversationCreateOrConnectWithoutlastReadInput
}

input ConversationCreateOneWithoutMessagesInput {
  create: ConversationCreateWithoutMessagesInput
  connect: ConversationWhereUniqueInput
  connectOrCreate: ConversationCreateOrConnectWithoutmessagesInput
}

input ConversationCreateOrConnectWithoutlastReadInput {
  where: ConversationWhereUniqueInput!
  create: ConversationCreateWithoutLastReadInput!
}

input ConversationCreateOrConnectWithoutmessagesInput {
  where: ConversationWhereUniqueInput!
  create: ConversationCreateWithoutMessagesInput!
}

input ConversationCreateOrConnectWithoutparticipantsInput {
  where: ConversationWhereUniqueInput!
  create: ConversationCreateWithoutParticipantsInput!
}

input ConversationCreateWithoutLastReadInput {
  createdAt: DateTime
  name: String!
  messages: MessageCreateManyWithoutConversationInput
  participants: PersonCreateManyWithoutConversationsInput
}

input ConversationCreateWithoutMessagesInput {
  createdAt: DateTime
  name: String!
  lastRead: LastReadCreateManyWithoutConversationInput
  participants: PersonCreateManyWithoutConversationsInput
}

input ConversationCreateWithoutParticipantsInput {
  createdAt: DateTime
  name: String!
  messages: MessageCreateManyWithoutConversationInput
  lastRead: LastReadCreateManyWithoutConversationInput
}

type ConversationEdge {
  """https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"""
  cursor: String!

  """https://facebook.github.io/relay/graphql/connections.htm#sec-Node"""
  node: Conversation!
}

input ConversationScalarWhereInput {
  AND: [ConversationScalarWhereInput!]
  OR: [ConversationScalarWhereInput!]
  NOT: [ConversationScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
}

input ConversationUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutConversationInput
  lastRead: LastReadUpdateManyWithoutConversationInput
  participants: PersonUpdateManyWithoutConversationsInput
}

input ConversationUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ConversationUpdateManyWithoutParticipantsInput {
  create: [ConversationCreateWithoutParticipantsInput!]
  connect: [ConversationWhereUniqueInput!]
  set: [ConversationWhereUniqueInput!]
  disconnect: [ConversationWhereUniqueInput!]
  delete: [ConversationWhereUniqueInput!]
  update: [ConversationUpdateWithWhereUniqueWithoutParticipantsInput!]
  updateMany: [ConversationUpdateManyWithWhereWithoutParticipantsInput!]
  deleteMany: [ConversationScalarWhereInput!]
  upsert: [ConversationUpsertWithWhereUniqueWithoutParticipantsInput!]
  connectOrCreate: [ConversationCreateOrConnectWithoutparticipantsInput!]
}

input ConversationUpdateManyWithWhereWithoutParticipantsInput {
  where: ConversationScalarWhereInput!
  data: ConversationUpdateManyMutationInput!
}

input ConversationUpdateOneRequiredWithoutLastReadInput {
  create: ConversationCreateWithoutLastReadInput
  connect: ConversationWhereUniqueInput
  update: ConversationUpdateWithoutLastReadInput
  upsert: ConversationUpsertWithoutLastReadInput
  connectOrCreate: ConversationCreateOrConnectWithoutlastReadInput
}

input ConversationUpdateOneRequiredWithoutMessagesInput {
  create: ConversationCreateWithoutMessagesInput
  connect: ConversationWhereUniqueInput
  update: ConversationUpdateWithoutMessagesInput
  upsert: ConversationUpsertWithoutMessagesInput
  connectOrCreate: ConversationCreateOrConnectWithoutmessagesInput
}

input ConversationUpdateWithoutLastReadInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutConversationInput
  participants: PersonUpdateManyWithoutConversationsInput
}

input ConversationUpdateWithoutMessagesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  lastRead: LastReadUpdateManyWithoutConversationInput
  participants: PersonUpdateManyWithoutConversationsInput
}

input ConversationUpdateWithoutParticipantsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutConversationInput
  lastRead: LastReadUpdateManyWithoutConversationInput
}

input ConversationUpdateWithWhereUniqueWithoutParticipantsInput {
  where: ConversationWhereUniqueInput!
  data: ConversationUpdateWithoutParticipantsInput!
}

input ConversationUpsertWithoutLastReadInput {
  update: ConversationUpdateWithoutLastReadInput!
  create: ConversationCreateWithoutLastReadInput!
}

input ConversationUpsertWithoutMessagesInput {
  update: ConversationUpdateWithoutMessagesInput!
  create: ConversationCreateWithoutMessagesInput!
}

input ConversationUpsertWithWhereUniqueWithoutParticipantsInput {
  where: ConversationWhereUniqueInput!
  update: ConversationUpdateWithoutParticipantsInput!
  create: ConversationCreateWithoutParticipantsInput!
}

input ConversationWhereUniqueInput {
  id: Int
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeNullableFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableFilter
}

type LastRead {
  lastRead: DateTime!
  conversation: Conversation!
  conversationID: Int!
  personID: Int!
  person: Person!
}

input LastReadCreateManyWithoutConversationInput {
  create: [LastReadCreateWithoutConversationInput!]
  connect: [LastReadWhereUniqueInput!]
  connectOrCreate: [LastReadCreateOrConnectWithoutconversationInput!]
}

input LastReadCreateManyWithoutPersonInput {
  create: [LastReadCreateWithoutPersonInput!]
  connect: [LastReadWhereUniqueInput!]
  connectOrCreate: [LastReadCreateOrConnectWithoutpersonInput!]
}

input LastReadCreateOrConnectWithoutconversationInput {
  where: LastReadWhereUniqueInput!
  create: LastReadCreateWithoutConversationInput!
}

input LastReadCreateOrConnectWithoutpersonInput {
  where: LastReadWhereUniqueInput!
  create: LastReadCreateWithoutPersonInput!
}

input LastReadCreateWithoutConversationInput {
  lastRead: DateTime!
  person: PersonCreateOneWithoutLastReadInput!
}

input LastReadCreateWithoutPersonInput {
  lastRead: DateTime!
  conversation: ConversationCreateOneWithoutLastReadInput!
}

input LastReadScalarWhereInput {
  AND: [LastReadScalarWhereInput!]
  OR: [LastReadScalarWhereInput!]
  NOT: [LastReadScalarWhereInput!]
  lastRead: DateTimeFilter
  personID: IntFilter
  conversationID: IntFilter
}

input LastReadUpdateManyMutationInput {
  lastRead: DateTimeFieldUpdateOperationsInput
}

input LastReadUpdateManyWithoutConversationInput {
  create: [LastReadCreateWithoutConversationInput!]
  connect: [LastReadWhereUniqueInput!]
  set: [LastReadWhereUniqueInput!]
  disconnect: [LastReadWhereUniqueInput!]
  delete: [LastReadWhereUniqueInput!]
  update: [LastReadUpdateWithWhereUniqueWithoutConversationInput!]
  updateMany: [LastReadUpdateManyWithWhereWithoutConversationInput!]
  deleteMany: [LastReadScalarWhereInput!]
  upsert: [LastReadUpsertWithWhereUniqueWithoutConversationInput!]
  connectOrCreate: [LastReadCreateOrConnectWithoutconversationInput!]
}

input LastReadUpdateManyWithoutPersonInput {
  create: [LastReadCreateWithoutPersonInput!]
  connect: [LastReadWhereUniqueInput!]
  set: [LastReadWhereUniqueInput!]
  disconnect: [LastReadWhereUniqueInput!]
  delete: [LastReadWhereUniqueInput!]
  update: [LastReadUpdateWithWhereUniqueWithoutPersonInput!]
  updateMany: [LastReadUpdateManyWithWhereWithoutPersonInput!]
  deleteMany: [LastReadScalarWhereInput!]
  upsert: [LastReadUpsertWithWhereUniqueWithoutPersonInput!]
  connectOrCreate: [LastReadCreateOrConnectWithoutpersonInput!]
}

input LastReadUpdateManyWithWhereWithoutConversationInput {
  where: LastReadScalarWhereInput!
  data: LastReadUpdateManyMutationInput!
}

input LastReadUpdateManyWithWhereWithoutPersonInput {
  where: LastReadScalarWhereInput!
  data: LastReadUpdateManyMutationInput!
}

input LastReadUpdateWithoutConversationInput {
  lastRead: DateTimeFieldUpdateOperationsInput
  person: PersonUpdateOneRequiredWithoutLastReadInput
}

input LastReadUpdateWithoutPersonInput {
  lastRead: DateTimeFieldUpdateOperationsInput
  conversation: ConversationUpdateOneRequiredWithoutLastReadInput
}

input LastReadUpdateWithWhereUniqueWithoutConversationInput {
  where: LastReadWhereUniqueInput!
  data: LastReadUpdateWithoutConversationInput!
}

input LastReadUpdateWithWhereUniqueWithoutPersonInput {
  where: LastReadWhereUniqueInput!
  data: LastReadUpdateWithoutPersonInput!
}

input LastReadUpsertWithWhereUniqueWithoutConversationInput {
  where: LastReadWhereUniqueInput!
  update: LastReadUpdateWithoutConversationInput!
  create: LastReadCreateWithoutConversationInput!
}

input LastReadUpsertWithWhereUniqueWithoutPersonInput {
  where: LastReadWhereUniqueInput!
  update: LastReadUpdateWithoutPersonInput!
  create: LastReadCreateWithoutPersonInput!
}

input LastReadWhereUniqueInput {
  personID_conversationID: PersonIDConversationIDCompoundUniqueInput
}

type Message {
  id: Int!
  content: String!
  conversation: Conversation!
  conversationID: Int!
  authorID: Int
  author: Person
  createdAt: DateTime!
}

input MessageCreateManyWithoutAuthorInput {
  create: [MessageCreateWithoutAuthorInput!]
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutauthorInput!]
}

input MessageCreateManyWithoutConversationInput {
  create: [MessageCreateWithoutConversationInput!]
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutconversationInput!]
}

input MessageCreateOrConnectWithoutauthorInput {
  where: MessageWhereUniqueInput!
  create: MessageCreateWithoutAuthorInput!
}

input MessageCreateOrConnectWithoutconversationInput {
  where: MessageWhereUniqueInput!
  create: MessageCreateWithoutConversationInput!
}

input MessageCreateWithoutAuthorInput {
  content: String!
  createdAt: DateTime
  conversation: ConversationCreateOneWithoutMessagesInput!
}

input MessageCreateWithoutConversationInput {
  content: String!
  createdAt: DateTime
  author: PersonCreateOneWithoutMessagesInput
}

input MessageScalarWhereInput {
  AND: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
  content: StringFilter
  authorID: IntNullableFilter
  conversationID: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
}

input MessageUpdateInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  author: PersonUpdateOneWithoutMessagesInput
  conversation: ConversationUpdateOneRequiredWithoutMessagesInput
}

input MessageUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input MessageUpdateManyWithoutAuthorInput {
  create: [MessageCreateWithoutAuthorInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  delete: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [MessageUpdateManyWithWhereWithoutAuthorInput!]
  deleteMany: [MessageScalarWhereInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutAuthorInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutauthorInput!]
}

input MessageUpdateManyWithoutConversationInput {
  create: [MessageCreateWithoutConversationInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  delete: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutConversationInput!]
  updateMany: [MessageUpdateManyWithWhereWithoutConversationInput!]
  deleteMany: [MessageScalarWhereInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutConversationInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutconversationInput!]
}

input MessageUpdateManyWithWhereWithoutAuthorInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyMutationInput!
}

input MessageUpdateManyWithWhereWithoutConversationInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyMutationInput!
}

input MessageUpdateWithoutAuthorInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  conversation: ConversationUpdateOneRequiredWithoutMessagesInput
}

input MessageUpdateWithoutConversationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  author: PersonUpdateOneWithoutMessagesInput
}

input MessageUpdateWithWhereUniqueWithoutAuthorInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateWithoutAuthorInput!
}

input MessageUpdateWithWhereUniqueWithoutConversationInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateWithoutConversationInput!
}

input MessageUpsertWithWhereUniqueWithoutAuthorInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateWithoutAuthorInput!
  create: MessageCreateWithoutAuthorInput!
}

input MessageUpsertWithWhereUniqueWithoutConversationInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateWithoutConversationInput!
  create: MessageCreateWithoutConversationInput!
}

input MessageWhereUniqueInput {
  id: Int
}

type Mutation {
  deleteOneMessage(where: MessageWhereUniqueInput!): Message
  updateOneMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  deleteOnePerson(where: PersonWhereUniqueInput!): Person
  createOneConversation(data: ConversationCreateInput!): Conversation!
  deleteOneConversation(where: ConversationWhereUniqueInput!): Conversation
  updateOneConversation(data: ConversationUpdateInput!, where: ConversationWhereUniqueInput!): Conversation
  addPersonToConversation(personId: Int!, conversationId: Int!): Conversation!
  removePersonFromConversation(personId: Int!, conversationId: Int!): Conversation!
  createMessage(content: String!, conversationId: Int!): Message!
  markConvAsRead(conversationId: Int!): LastRead!
  login(username: String!, password: String!): Person!
  logout: Person!
  register(email: String!, username: String!, password: String!): Person!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeNullableFilter
}

input NestedIntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input NestedIntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableFilter
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

"""
PageInfo cursor, as defined in https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  Used to indicate whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Used to indicate whether more edges exist prior to the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """
  The cursor corresponding to the first nodes in edges. Null if the connection is empty.
  """
  startCursor: String

  """
  The cursor corresponding to the last nodes in edges. Null if the connection is empty.
  """
  endCursor: String
}

type Person {
  id: Int!
  username: String!
  email: String!
  isAdmin: Boolean!
  createdAt: DateTime!
  lastSeen: DateTime
  isActive: Boolean!
  conversations(
    """Returns the first n elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor"""
    after: String

    """Returns the last n elements from the list."""
    last: Int

    """Returns the elements in the list that come before the specified cursor"""
    before: String
  ): ConversationConnection!
}

input PersonCreateManyWithoutConversationsInput {
  create: [PersonCreateWithoutConversationsInput!]
  connect: [PersonWhereUniqueInput!]
  connectOrCreate: [PersonCreateOrConnectWithoutconversationsInput!]
}

input PersonCreateOneWithoutLastReadInput {
  create: PersonCreateWithoutLastReadInput
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutlastReadInput
}

input PersonCreateOneWithoutMessagesInput {
  create: PersonCreateWithoutMessagesInput
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutmessagesInput
}

input PersonCreateOrConnectWithoutconversationsInput {
  where: PersonWhereUniqueInput!
  create: PersonCreateWithoutConversationsInput!
}

input PersonCreateOrConnectWithoutlastReadInput {
  where: PersonWhereUniqueInput!
  create: PersonCreateWithoutLastReadInput!
}

input PersonCreateOrConnectWithoutmessagesInput {
  where: PersonWhereUniqueInput!
  create: PersonCreateWithoutMessagesInput!
}

input PersonCreateWithoutConversationsInput {
  createdAt: DateTime
  email: String!
  isAdmin: Boolean
  lastSeen: DateTime
  username: String!
  hash: String!
  messages: MessageCreateManyWithoutAuthorInput
  lastRead: LastReadCreateManyWithoutPersonInput
}

input PersonCreateWithoutLastReadInput {
  createdAt: DateTime
  email: String!
  isAdmin: Boolean
  lastSeen: DateTime
  username: String!
  hash: String!
  messages: MessageCreateManyWithoutAuthorInput
  conversations: ConversationCreateManyWithoutParticipantsInput
}

input PersonCreateWithoutMessagesInput {
  createdAt: DateTime
  email: String!
  isAdmin: Boolean
  lastSeen: DateTime
  username: String!
  hash: String!
  lastRead: LastReadCreateManyWithoutPersonInput
  conversations: ConversationCreateManyWithoutParticipantsInput
}

input PersonIDConversationIDCompoundUniqueInput {
  personID: Int!
  conversationID: Int!
}

input PersonScalarWhereInput {
  AND: [PersonScalarWhereInput!]
  OR: [PersonScalarWhereInput!]
  NOT: [PersonScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  isAdmin: BoolFilter
  lastSeen: DateTimeNullableFilter
  username: StringFilter
  hash: StringFilter
}

input PersonUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
}

input PersonUpdateManyWithoutConversationsInput {
  create: [PersonCreateWithoutConversationsInput!]
  connect: [PersonWhereUniqueInput!]
  set: [PersonWhereUniqueInput!]
  disconnect: [PersonWhereUniqueInput!]
  delete: [PersonWhereUniqueInput!]
  update: [PersonUpdateWithWhereUniqueWithoutConversationsInput!]
  updateMany: [PersonUpdateManyWithWhereWithoutConversationsInput!]
  deleteMany: [PersonScalarWhereInput!]
  upsert: [PersonUpsertWithWhereUniqueWithoutConversationsInput!]
  connectOrCreate: [PersonCreateOrConnectWithoutconversationsInput!]
}

input PersonUpdateManyWithWhereWithoutConversationsInput {
  where: PersonScalarWhereInput!
  data: PersonUpdateManyMutationInput!
}

input PersonUpdateOneRequiredWithoutLastReadInput {
  create: PersonCreateWithoutLastReadInput
  connect: PersonWhereUniqueInput
  update: PersonUpdateWithoutLastReadInput
  upsert: PersonUpsertWithoutLastReadInput
  connectOrCreate: PersonCreateOrConnectWithoutlastReadInput
}

input PersonUpdateOneWithoutMessagesInput {
  create: PersonCreateWithoutMessagesInput
  connect: PersonWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: PersonUpdateWithoutMessagesInput
  upsert: PersonUpsertWithoutMessagesInput
  connectOrCreate: PersonCreateOrConnectWithoutmessagesInput
}

input PersonUpdateWithoutConversationsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutAuthorInput
  lastRead: LastReadUpdateManyWithoutPersonInput
}

input PersonUpdateWithoutLastReadInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutAuthorInput
  conversations: ConversationUpdateManyWithoutParticipantsInput
}

input PersonUpdateWithoutMessagesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  lastRead: LastReadUpdateManyWithoutPersonInput
  conversations: ConversationUpdateManyWithoutParticipantsInput
}

input PersonUpdateWithWhereUniqueWithoutConversationsInput {
  where: PersonWhereUniqueInput!
  data: PersonUpdateWithoutConversationsInput!
}

input PersonUpsertWithoutLastReadInput {
  update: PersonUpdateWithoutLastReadInput!
  create: PersonCreateWithoutLastReadInput!
}

input PersonUpsertWithoutMessagesInput {
  update: PersonUpdateWithoutMessagesInput!
  create: PersonCreateWithoutMessagesInput!
}

input PersonUpsertWithWhereUniqueWithoutConversationsInput {
  where: PersonWhereUniqueInput!
  update: PersonUpdateWithoutConversationsInput!
  create: PersonCreateWithoutConversationsInput!
}

input PersonWhereUniqueInput {
  email: String
  id: Int
  username: String
}

type Query {
  people(first: Int, last: Int, before: PersonWhereUniqueInput, after: PersonWhereUniqueInput): [Person!]!
  conversations(first: Int, last: Int, before: ConversationWhereUniqueInput, after: ConversationWhereUniqueInput): [Conversation!]!
  message(where: MessageWhereUniqueInput!): Message
  messages(first: Int, last: Int, before: MessageWhereUniqueInput, after: MessageWhereUniqueInput): [Message!]!
  conversation(whereId: Int!): Conversation!
  me: Person!
  person(where: PersonWhereUniqueInput!): Person!
  sessionOwner: Person!
}

enum QueryMode {
  default
  insensitive
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

type Subscription {
  newMessages(conversationId: Int!): Message!
  personActiveStatus(userId: Int!): Boolean!
}

